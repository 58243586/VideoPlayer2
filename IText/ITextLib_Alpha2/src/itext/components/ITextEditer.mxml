<?xml version="1.0" encoding="utf-8"?>
<!--
     IText的编辑器用来进行IText文件的编辑，生成可被IText播放器解析的IText数据
-->
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
         xmlns:s="library://ns.adobe.com/flex/spark"
         xmlns:mx="library://ns.adobe.com/flex/mx"
         width="400"
         height="300"
         creationComplete="iText_creationComplete()"
         xmlns:components="itext.components.*">
    <s:layout>
        <s:BasicLayout />
    </s:layout>
    <fx:Script>
        <![CDATA[
            import com.adobe.images.JPGEncoder;
            import com.adobe.images.PNGEncoder;
            import com.jing.utils.TextAreaUtil;
            
            import flash.text.engine.FontWeight;
            import flash.text.engine.TextRotation;
            
            import flashx.textLayout.conversion.ConversionType;
            import flashx.textLayout.conversion.TextConverter;
            import flashx.textLayout.formats.BackgroundColor;
            import flashx.textLayout.formats.LeadingModel;
            import flashx.textLayout.formats.TextDecoration;
            import flashx.textLayout.formats.TextLayoutFormat;
            
            import itext.constants.EffectTypeConstant;
            import itext.constants.TextBorderConstant;
            import itext.constants.TriggerConstant;
            import itext.events.InTextEditerEvent;
            import itext.framework.ITextFormat;
            import itext.tools.RectBlock;
            import itext.views.editerElements.AnswerSetButton;
            import itext.views.editerElements.QuestionInputBox;
            import itext.views.editerElements.TextBorder;
            import itext.views.editerElements.marks.AnswerMark;
            import itext.views.editerElements.marks.EffectMark;
            import itext.views.editerElements.marks.KeywordMark;
            import itext.views.editerElements.marks.QuestionMark;
            import itext.views.playerElements.QuestionBorder;
            import itext.vo.AnswerVO;
            import itext.vo.EffectVO;
            import itext.vo.KeywordVO;
            import itext.vo.QuestionVO;
            
            import mx.collections.ArrayCollection;
            import mx.controls.Alert;
            import mx.controls.TextArea;
            import mx.core.FlexSprite;
            import mx.core.UIComponent;
            import mx.core.UITextField;
            import mx.core.mx_internal;
            import mx.events.ResizeEvent;
            import mx.managers.PopUpManager;
            
            import spark.components.Label;
            import spark.components.List;
            import spark.components.supportClasses.GroupBase;

            [Bindable]
            private var paddingX:int = 10;

            //Itext数据
            private var itextXML:XML = null;

            //是否更新
            private var isUpdateXML:Boolean = false;

            //文本长度记录
            private var oldTextLength:int = 0;

            //--------------------数据对象定义-----------------------
            //
            //

            private var keywords:Vector.<KeywordVO> = new Vector.<KeywordVO>();

            private var effects:Vector.<EffectVO> = new Vector.<EffectVO>();

            private var questions:Vector.<QuestionVO> = new Vector.<QuestionVO>();


            //--------------------显示对象定义-------------------
            //
            //

            private var keywordMarks:Vector.<KeywordMark> = new Vector.<KeywordMark>();

            private var questionMarks:Vector.<QuestionMark> = new Vector.<QuestionMark>();

            private var answerMarks:Vector.<AnswerMark> = new Vector.<AnswerMark>();

            private var effectMarks:Vector.<EffectMark> = new Vector.<EffectMark>();

            //背景框
            private var textBorder:TextBorder = new TextBorder();

            /**
             * 问题输入框
             */
            private var questionInputBox:QuestionInputBox = new QuestionInputBox();

            //选中并且被激活的问题
            private var selectedQuestionMark:QuestionMark = null;

            //设置问题答案的按钮
            private var answerSetButton:AnswerSetButton = new AnswerSetButton();

            /**
             * 组件创建完毕时执行
             */
            private function iText_creationComplete():void
            {
                //记录文本的长度
                oldTextLength = textArea.text.length;

                //设置文本边框
                setTextBorder(TextBorderConstant.BORDER_ONE);

                //如果有XML数据且还没有更新，则调用更新
                if (isUpdateXML == false && itextXML != null)
                {
                    setIText(itextXML);
                }

                initListeners();
            }

            private function initListeners():void
            {
                answerSetButton.addEventListener(MouseEvent.CLICK, answerSetButton_clickHandler);
                questionInputBox.addEventListener(Event.CHANGE, questionInputBox_changeHandler);
				textArea.addEventListener(FocusEvent.FOCUS_IN, myFocusInHandler);
            }
			
			private function myFocusInHandler(e:FocusEvent):void
			{
				IME.enabled = true;
			}

            private function questionInputBox_changeHandler(e:Event):void
            {
                this.dispatchEvent(new InTextEditerEvent(InTextEditerEvent.QUESTION_INPUT_BOX_CHANGE, this.keywords, this.questions, this.effects));
            }

            private function answerSetButton_clickHandler(e:MouseEvent):void
            {
                if (selectedQuestionMark != null)
                {
                    setQuestionAnswer(selectedQuestionMark.vo.questionIndex);

                    if (answerSetButton.owner == this)
                    {
                        this.removeElement(answerSetButton);
                    }
                }
            }


            /**
             * 文本框大小改变产生的事件
             */
            private function textArea_resizeHandler(e:ResizeEvent):void
            {
                updateMarks();
                this.setTextBorder(textBorder.borderName);
            }

            /**
             * 文本框发生选择范围改变的事件
             */
            private function textArea_selectionChangeHandler(e:Event):void
            {
                this.dispatchEvent(new InTextEditerEvent(InTextEditerEvent.TEXT_SELECTION, keywords, questions, effects));
            }

            /**
             * 文本框内容改变的事件
             * 如果改变的数量大于0，表示是输入了新的字符
             * 如果改变的数量小于0，表示是删除了字符
             */
            private function textArea_changeHandler(e:Event):void
            {
                var changeCount:int = textArea.text.length - oldTextLength;

                if (changeCount > 0)
                {
                    updateIndexs(this.selectionBeginIndex, changeCount);
                }
                else if (changeCount < 0)
                {
                    updateIndexs(this.selectionBeginIndex, changeCount);
                }

                oldTextLength = textArea.text.length;

                updateMarks();


                //判断文本的内容，如果文本的内容超出了文本框的大小，则将文本框的高度改变以适应内容的显示高度
                //反之如果文本内容太少，则将文本框调到不会让滚动条出现的高度
                if (textArea.textDisplay.contentHeight >= textArea.height)
                {
                    textArea.height = textArea.textDisplay.contentHeight + 10;
                }
                else if (textArea.textDisplay.contentHeight <= scroller.height - 10)
                {
                    textArea.height = scroller.height - 10;
                }
                else if (textArea.textDisplay.contentHeight < textArea.height && textArea.textDisplay.contentHeight > scroller.height - 10)
                {
                    textArea.height = textArea.textDisplay.contentHeight + 10;
                }
            }

            /**
             * 根据索引更新标记的位置
             * @param caretIndex  用来进行判断的索引参照位置
             * @param chagneCount 改变的文本的字符数（增加或删除）
             * 在这里用到了Vector类的concat()方法，来拷贝一个Vector类，这样的话，在进行删除的情况下不会让原本的Vector类的索引变乱
             *
             */
            private function updateIndexs(caretIndex:int, changeCount:int):void
            {
                //是否有标记的内容被改变
                var isChangeInMark:Boolean = false;

                var i:int = 0;

                var keywords:Vector.<KeywordVO> = new Vector.<KeywordVO>();
                keywords = this.keywords.concat();

                for (i = 0; i < keywords.length; i++)
                {
                    isChangeInMark = delayIndexChange(caretIndex, changeCount, keywords[i]);
                }

                var effects:Vector.<EffectVO> = new Vector.<EffectVO>();
                effects = this.effects.concat();

                for (i = 0; i < effects.length; i++)
                {
                    isChangeInMark = delayIndexChange(caretIndex, changeCount, effects[i]);
                }


                var j:int = 0;

                var questions:Vector.<QuestionVO> = new Vector.<QuestionVO>();
                questions = this.questions.concat();

                //删除操作的光标索引位置起点
                var delBeginIndex:int = Math.min(caretIndex, caretIndex - changeCount);
                //删除操作的光标索引位置终点
                var delEndIndex:int = Math.max(caretIndex, caretIndex - changeCount);

                for (i = 0; i < questions.length; i++)
                {
                    if (questions[i].questionIndex < delEndIndex && questions[i].questionIndex > delBeginIndex)
                    {
                        delQuestion(questions[i]);
                        continue;
                    }
                    else if (questions[i].questionIndex >= caretIndex)
                    {
                        questions[i].questionIndex += changeCount;
                    }

                    var answers:Vector.<AnswerVO> = new Vector.<AnswerVO>();
                    answers = questions[i].answers.concat();

                    for (j = 0; j < answers.length; j++)
                    {
                        isChangeInMark = delayIndexChange(caretIndex, changeCount, answers[j]);
                    }
                }
                /*
                 * 20100621：在有没有isChangeInMark的情况下都广播事件跟新列表,如果效率不够，则加入判断isChangeInMark
                 */

                //                if (isChangeInMark == true)
                //                {
                this.dispatchEvent(new InTextEditerEvent(InTextEditerEvent.EDITER_CHANGE, this.keywords, this.questions, this.effects));
                //                }
            }


            /**
             * 处理预埋的内容范围的内部索引有改变的标记
             * 根据对改变的字符的判断来确定对当前受到影响的预埋内容的操作
             *
             */
            private function delayIndexChange(caretIndex:int, changeCount:int, preburiedVO:Object):Boolean
            {
                //改变前光标的位置
                var oldIndex:int = caretIndex - changeCount;

                //删除操作的光标索引位置起点
                var delBeginIndex:int = Math.min(caretIndex, caretIndex - changeCount);
                //删除操作的光标索引位置终点
                var delEndIndex:int = Math.max(caretIndex, caretIndex - changeCount);
                trace("改变的索引区间是：", delBeginIndex, " 到 ", delEndIndex);

                //是否有标记的内容被改变
                var isChangeInMark:Boolean = false;

                if (changeCount > 0) //如果是增加字符串
                {
                    if (preburiedVO.beginIndex >= oldIndex)
                    {
                        preburiedVO.beginIndex += changeCount;
                        preburiedVO.endIndex += changeCount;
                    }
                    else if (preburiedVO.beginIndex < oldIndex && preburiedVO.endIndex > oldIndex)
                    {
                        preburiedVO.endIndex += changeCount;
                        isChangeInMark = true;
                    }
                }
                else if (changeCount < 0)
                {
                    isChangeInMark = true;

                    if (preburiedVO.beginIndex >= delEndIndex)
                    {
                        preburiedVO.beginIndex += changeCount;
                        preburiedVO.endIndex += changeCount;
                        isChangeInMark = false;
                    }
                    else if (preburiedVO.beginIndex > delBeginIndex && preburiedVO.beginIndex < delEndIndex && preburiedVO.endIndex > delBeginIndex && preburiedVO.endIndex > delEndIndex)
                    {
                        preburiedVO.beginIndex -= (preburiedVO.beginIndex - delBeginIndex);
                        preburiedVO.endIndex -= (delEndIndex - delBeginIndex);
                    }
                    else if (preburiedVO.beginIndex <= delBeginIndex && preburiedVO.beginIndex < delEndIndex && preburiedVO.endIndex > delBeginIndex && preburiedVO.endIndex >= delEndIndex)
                    {
                        preburiedVO.endIndex -= (delEndIndex - delBeginIndex);
                    }
                    else if (preburiedVO.beginIndex < delBeginIndex && preburiedVO.beginIndex < delEndIndex && preburiedVO.endIndex > delBeginIndex && preburiedVO.endIndex < delEndIndex)
                    {
                        preburiedVO.endIndex -= (preburiedVO.endIndex - delBeginIndex);
                    }
                    else if (preburiedVO.beginIndex >= delBeginIndex && preburiedVO.endIndex <= delEndIndex)
                    {
                        preburiedVO.beginIndex = preburiedVO.endIndex;
                    }
                    else
                    {
                        isChangeInMark = false;
                    }
                }

                if (preburiedVO.beginIndex == preburiedVO.endIndex)
                {
                    delPreburied(preburiedVO);
                }
                else
                {
                    //preburiedVO.content = textArea.getTextField().text.substring(preburiedVO.beginIndex, preburiedVO.endIndex);
                }

                return isChangeInMark;
            }

            /**
             * 构建IText描述文档，描述IText编辑出的内容
             */
            private function createITextXML():XML
            {
                var itextXML:XML = <IText><Content/><Keywords/><Effects/><Questions/></IText>;

                itextXML.Content = TextConverter.export(textArea.textFlow, ITextFormat.TEXT_CONVERTER_FORMAT, ConversionType.STRING_TYPE);
                itextXML.Content.@border = textBorder.borderName;
                itextXML.Content.@backgroundColor = textBorder.borderColor;
                itextXML.Content.@width = textArea.width;
                itextXML.Content.@height = textArea.height;
                itextXML.Content.@scrollWidth = scroller.width;
                itextXML.Content.@scrollHeight = scroller.height;

                var i:int = 0;
                var j:int = 0;

                for (i = 0; i < keywords.length; i++)
                {
                    var keywordNode:XML = <Keyword/>;
                    keywordNode.@beginIndex = keywords[i].beginIndex;
                    keywordNode.@endIndex = keywords[i].endIndex;
                    keywordNode.@trigger = keywords[i].trigger;
                    keywordNode.@fontColor = keywords[i].fontColor;
                    keywordNode.@border = keywords[i].border;
                    keywordNode.@borderColor = keywords[i].borderColor;
                    keywordNode.@param = keywords[i].param;
                    XML(itextXML.Keywords).appendChild(keywordNode);
                }

                for (i = 0; i < effects.length; i++)
                {
                    var effectNode:XML = <Effect/>;
                    effectNode.@beginIndex = effects[i].beginIndex;
                    effectNode.@endIndex = effects[i].endIndex;
                    effectNode.@trigger = effects[i].trigger;
                    effectNode.@effectType = effects[i].effectType;
                    //                    effectNode.@effectAction = effects[i].effectAction;
                    effectNode.@param = effects[i].param;
                    XML(itextXML.Effects).appendChild(effectNode);
                }

                for (i = 0; i < questions.length; i++)
                {
                    var questionNode:XML = <Question><Content>{questions[i].content}</Content><Answers/></Question>;
                    questionNode.@questionIndex = questions[i].questionIndex;

                    for (j = 0; j < questions[i].answers.length; j++)
                    {
                        var answerNode:XML = <Answer>{questions[i].answers[j].content}</Answer>;
                        answerNode.@beginIndex = questions[i].answers[j].beginIndex;
                        answerNode.@endIndex = questions[i].answers[j].endIndex;
                        XML(questionNode.Answers).appendChild(answerNode);
                    }
                    XML(itextXML.Questions).appendChild(questionNode);
                }
                return itextXML;
            }

            //---------------------外部公共接口------------------
            //
            //

            /*
             ******************** 公开的属性 ********************8
             */

            /**
             * 得到选择文本范围的起始索引
             */
            public function get selectionBeginIndex():int
            {
                return Math.min(textArea.selectionActivePosition, textArea.selectionAnchorPosition);
            }

            /**
             * 得到选择文本范围的结束索引
             */
            public function get selectionEndIndex():int
            {
                return Math.max(textArea.selectionActivePosition, textArea.selectionAnchorPosition);
            }

            /*-----------------------------------------------------------*/

            /*
             ***************** 公开的方法 *********************
             */

            /**
             * 得到预埋的关键词的VO集合
             */
            public function getKeywords():Vector.<KeywordVO>
            {
                return keywords;
            }

            /**
             * 得到预埋的特效的VO集合
             */
            public function getEffects():Vector.<EffectVO>
            {
                return effects;
            }

            /**
             * 得到预埋的问题的VO集合
             */
            public function getQuestions():Vector.<QuestionVO>
            {
                return questions;
            }

            /**
             *获取IText数据
             *
             */
            public function getIText():XML
            {
                return createITextXML();
            }

            /**
             * 设置IText数据
             *
             */
            public function setIText(xml:XML):void
            {
                itextXML = xml;

                if (this.owner == null)
                {
                    return;
                }

                clear();

                isUpdateXML = true;

                textArea.textFlow = TextConverter.importToFlow(itextXML.Content.toString(), TextConverter.TEXT_FIELD_HTML_FORMAT);
                textArea.validateNow();

                keywords.length = 0;
                effects.length = 0;
                questions.length = 0;

                //                textArea.width = Number(itextXML.Content.@width);
                //                textArea.height = Number(itextXML.Content.@height);

                var backgroundColor:int = int(itextXML.Content.@backgroundColor);
                var borderName:String = itextXML.Content.@border;

                if (borderName != "")
                {
                    setTextBorder(borderName);
                    setBackgroundColor(backgroundColor);
                }

                var keywordVO:KeywordVO = null;

                for each (var keywordNode:XML in itextXML.Keywords.Keyword)
                {
                    keywordVO = new KeywordVO();
                    keywordVO.beginIndex = keywordNode.@beginIndex;
                    keywordVO.endIndex = keywordNode.@endIndex;
                    keywordVO.trigger = keywordNode.@trigger;
                    keywordVO.fontColor = keywordNode.@fontColor;
                    keywordVO.border = keywordNode.@border;
                    keywordVO.borderColor = keywordNode.@borderColor;
                    keywordVO.param = keywordNode.@param;
                    keywords.push(keywordVO);

                    createKeywordMark(keywordVO);
                    updateKeywordMark(keywordVO);
                }

                var effectVO:EffectVO = null;

                for each (var effectNode:XML in itextXML.Effects.Effect)
                {
                    effectVO = new EffectVO();
                    effectVO.beginIndex = int(effectNode.@beginIndex);
                    effectVO.endIndex = int(effectNode.@endIndex);
                    effectVO.trigger = effectNode.@trigger;
                    effectVO.effectType = effectNode.@effectType;
                    effectVO.param = effectNode.@param;
                    effects.push(effectVO);

                    createEffectMark(effectVO);
                    updateEffectMark(effectVO);
                }

                var questionVO:QuestionVO = null;

                for each (var questionNode:XML in itextXML.Questions.Question)
                {
                    questionVO = new QuestionVO();
                    questionVO.questionIndex = int(questionNode.@questionIndex);
                    questionVO.content = questionNode.Content.toString();

                    for each (var answerNode:XML in questionNode.Answers.Answer)
                    {
                        var answerVO:AnswerVO = new AnswerVO();
                        answerVO.beginIndex = int(answerNode.@beginIndex);
                        answerVO.endIndex = int(answerNode.@endIndex);
                        answerVO.questionIndex = questionVO.questionIndex;
                        answerVO.content = answerNode.toString();
                        questionVO.answers.push(answerVO);

                        createAnswerMark(answerVO);
                        updateAnswerMark(answerVO);
                    }
                    questions.push(questionVO);

                    createQuestionMark(questionVO);
                    updateQuestionMark(questionVO);
                }

                this.dispatchEvent(new InTextEditerEvent(InTextEditerEvent.EDITER_CHANGE, keywords, questions, effects));
            }

            /**
             * 删除预埋内容
             * @param valueObject 可以为KeywordVO|QuestionVO|AnswerVO|EffectVO任意一种
             */
            public function delPreburied(valueObject:Object):void
            {
                if (valueObject is KeywordVO)
                {
                    delKeyword(valueObject as KeywordVO);
                }
                else if (valueObject is QuestionVO)
                {
                    delQuestion(valueObject as QuestionVO);
                }
                else if (valueObject is AnswerVO)
                {
                    delAnswer(valueObject as AnswerVO);
                }
                else if (valueObject is EffectVO)
                {
                    delEffect(valueObject as EffectVO);
                }
            }


            /**
             * 设置背景颜色
             * @param color 颜色值
             */
            public function setBackgroundColor(color:int):void
            {
                textBorder.changeColor(color);
            }

            /**
             * 设置边框
             * @param textBorderName 文本框的名字，可参照itext.constants.TextBorderConstant类
             */
            public function setTextBorder(textBorderName:String):void
            {
                if (TextBorderConstant.borders.indexOf(textBorderName) != -1)
                {
                    this.addElementAt(textBorder, 0);

                    textBorder.updateBorder(textBorderName, scroller.width, scroller.height);
                }
            }

            /**
             * 设置选中指定范围文本
             *	@param beginIndex 开始的索引
             *  @param endIndex 结束的索引
             * 	@param isSendNotice 是否发送一个选中文本内容的通知
             */
            public function setSelection(beginIndex:int, endIndex:int, isSendNotice:Boolean = true):void
            {
                textArea.selectRange(beginIndex, endIndex);

                if (isSendNotice == true)
                {
                    this.dispatchEvent(new InTextEditerEvent(InTextEditerEvent.TEXT_SELECTION));
                }
            }

            /**
             * 检查索引的范围是否被特效占用了
             * 如果被占用了，返回flash
             * 如果起始索引和结束索引都一样，返回该对象
             * 如果没有被占用，返回true
             *
             */
            public function checkEffect(beginIndex:int, endIndex:int):Object
            {
                var result:Object = true;

                var i:int = 0;

                for (i = 0; i < effects.length; i++)
                {
                    if (beginIndex == effects[i].beginIndex && endIndex == effects[i].endIndex)
                    {
                        result = effects[i];
                        break;
                    }
                    else if (beginIndex > effects[i].beginIndex && beginIndex < effects[i].endIndex)
                    {
                        result = false;
                        break;
                    }
                    else if (endIndex > effects[i].beginIndex && beginIndex < effects[i].endIndex)
                    {
                        result = false;
                        break;
                    }
                }
                return result;
            }

            /**
             * 检查索引的范围是否被关键词句占用了
             * 如果被占用了，返回flash
             * 如果起始索引和结束索引都一样，返回该对象
             * 如果没有被占用，返回true
             */
            public function checkKeyword(beginIndex:int, endIndex:int):Object
            {
                var result:Object = true;

                var i:int = 0;

                for (i = 0; i < keywords.length; i++)
                {
                    if (beginIndex == keywords[i].beginIndex && endIndex == keywords[i].endIndex)
                    {
                        result = keywords[i];
                        break;
                    }
                    else if (beginIndex > keywords[i].beginIndex && beginIndex < keywords[i].endIndex)
                    {
                        result = false;
                        break;
                    }
                    else if (endIndex > keywords[i].beginIndex && beginIndex < keywords[i].endIndex)
                    {
                        result = false;
                        break;
                    }
                }

                return result;
            }

            /**
             * 更新标记的布局
             *
             *
             */
            public function updateMarks():void
            {
                textArea.validateNow();

                var i:int = 0;

                for (i = 0; i < effects.length; i++)
                {
                    updateEffectMark(effects[i]);
                }

                for (i = 0; i < keywords.length; i++)
                {
                    updateKeywordMark(keywords[i]);
                }

                for (i = 0; i < questions.length; i++)
                {
                    for (var j:int = 0; j < questions[i].answers.length; j++)
                    {
                        updateAnswerMark(questions[i].answers[j]);
                    }
                    updateQuestionMark(questions[i]);
                }
            }

            /**
             * 清理所有的显示对象
             *
             */
            public function clear():void
            {
                clearKeywordMarks();
                clearEffectMarks();
                clearQuestionMarks();
                textArea.text = "";
            }

            //---------------------设置关键词相关-------------------
            /**
             * 设置关键词句
             * @param type 设置效果类型
             * @param type 触发器类型
             * @param type 参数
             */
            public function setKeyword(fontColor:uint, border:String, borderColor:uint, trigger:String, param:Object = null):void
            {
                var beginIndex:int = this.selectionBeginIndex;
                var endIndex:int = this.selectionEndIndex;

                if (beginIndex == endIndex)
                {
                    //如果没有框选，则跳出
                    return;
                }


                var checkEffectResult:Object = checkEffect(beginIndex, endIndex);
                var checkKeywordResult:Object = checkKeyword(beginIndex, endIndex);

                var keywordVO:KeywordVO = null;

                if (checkEffectResult == true && checkKeywordResult == true)
                {
                    //创建新的对象
                    keywordVO = new KeywordVO();
                    keywords.push(keywordVO);
                    createKeywordMark(keywordVO);
                }
                else if (checkEffectResult == true && checkKeywordResult is KeywordVO)
                {
                    //覆盖之前设置的关键词句
                    keywordVO = checkKeywordResult as KeywordVO;

                    trace("之前的关键词句被覆盖!");
                }
                else if (checkEffectResult is EffectVO)
                {
                    //覆盖之前设置的特效
                    keywordVO = new KeywordVO();
                    keywords.push(keywordVO);
                    createKeywordMark(keywordVO);

                    //删除在特效中的对象
                    //                    var effectIndex:int = effects.indexOf(checkEffectResult);
                    //                    effects.splice(effectIndex, 1);
                    delEffect(checkEffectResult as EffectVO);
                    trace("之前的特效被覆盖!");

                }
                else
                {
                    Alert.show("有交错！不能设置");
                }

                if (keywordVO != null)
                {
                    keywordVO.beginIndex = beginIndex;
                    keywordVO.endIndex = endIndex;
                    keywordVO.fontColor = fontColor;
                    keywordVO.border = border;
                    keywordVO.borderColor = borderColor;
                    keywordVO.trigger = trigger;
                    keywordVO.param = param;
                    keywordVO.content = textArea.text.substring(beginIndex, endIndex);
                    updateKeywordMark(keywordVO);
                    //					this.dispatchEvent(new Event("change"));

                    this.dispatchEvent(new InTextEditerEvent(InTextEditerEvent.EDITER_CHANGE, keywords, questions, effects));
                }
            }


            //--------------------------设置问题-----------------
            /**
             * 设置问题
             * @param 问题的内容
             */

            public function setQuestion(content:String = ""):void
            {

                var beginIndex:int = selectionBeginIndex;

                if (beginIndex < 0)
                {
					beginIndex = 0;
                }

                var questionVO:QuestionVO = null;

                for (var i:int = 0; i < questions.length; i++)
                {
                    if (questions[i].questionIndex == beginIndex)
                    {
                        trace("覆盖了一个之前的问题");
                        questionVO = questions[i];
                        break;
                    }
                }

                if (questionVO == null)
                {
                    questionVO = new QuestionVO();
                    questions.push(questionVO);
                    createQuestionMark(questionVO);
                }

                questionVO.content = content;
                questionVO.questionIndex = beginIndex;

                var questionMark:QuestionMark = updateQuestionMark(questionVO);

                if (questionMark != null)
                {
                    activateQuestion(questionMark);
                }
                this.dispatchEvent(new InTextEditerEvent(InTextEditerEvent.EDITER_CHANGE, keywords, questions, effects));

            }


            //----------------------设置答案-------------------------
            /**
             * 设置问题答案
             * @param questionIndex 问题索引位置
             *
             */
            public function setQuestionAnswer(questionIndex:int):void
            {

                var beginIndex:int = this.selectionBeginIndex;
                var endIndex:int = this.selectionEndIndex;

                if (beginIndex == endIndex)
                {
                    return;
                }

                var question:QuestionVO = null;

                var answerVO:AnswerVO = null;

                for (var i:int = 0; i < questions.length; i++)
                {
                    if (questions[i].questionIndex == questionIndex)
                    {
                        question = questions[i];

                        for (var answerIndex:int = 0; answerIndex < questions[i].answers.length; answerIndex++)
                        {
                            if (questions[i].answers[answerIndex].beginIndex == beginIndex && questions[i].answers[answerIndex].endIndex == endIndex)
                            {
                                answerVO = questions[i].answers[answerIndex];
                                break;
                            }
                        }
                    }
                }

                if (answerVO == null)
                {
                    answerVO = new AnswerVO();
                    createAnswerMark(answerVO);
                    question.answers.push(answerVO);
                }

                answerVO.beginIndex = beginIndex;
                answerVO.endIndex = endIndex;
                answerVO.content = textArea.text.substring(beginIndex, endIndex);

                updateAnswerMark(answerVO);
                this.dispatchEvent(new InTextEditerEvent(InTextEditerEvent.EDITER_CHANGE, keywords, questions, effects));
            }


            //----------------设置特效------------------------


            /**
             * 设置特效
             */
            public function setEffect(effect:String, trigger:String, param:Object = null):void
            {

                var beginIndex:int = this.selectionBeginIndex;
                var endIndex:int = this.selectionEndIndex;

                if (beginIndex == endIndex)
                {
                    return;
                }

                var checkEffectResult:Object = checkEffect(beginIndex, endIndex);
                var checkKeywordResult:Object = checkKeyword(beginIndex, endIndex);

                var effectVO:EffectVO = null;

                if (checkKeywordResult == true && checkEffectResult == true)
                {
                    //创建新的对象
                    effectVO = new EffectVO();
                    effects.push(effectVO);
                    createEffectMark(effectVO);
                }
                else if (checkKeywordResult == true && checkEffectResult is EffectVO)
                {
                    //覆盖之前特效词句
                    effectVO = checkEffectResult as EffectVO;

                    trace("之前的关键词句被覆盖!");
                }
                else if (checkKeywordResult is KeywordVO)
                {
                    //覆盖之前设置的关键字
                    effectVO = new EffectVO();
                    effects.push(effectVO);

                    createEffectMark(effectVO);

                    //删除在关键字中的对象
                    //                    var keywordIndex:int = keywords.indexOf(checkKeywordResult);
                    //                    keywords.splice(keywordIndex, 1);
                    delKeyword(checkKeywordResult as KeywordVO);

                    trace("之前的特效被覆盖!");

                }
                else
                {
                    Alert.show("有交错！不能设置");
                }

                if (effectVO != null)
                {
                    effectVO.beginIndex = beginIndex;
                    effectVO.endIndex = endIndex;
                    effectVO.effectType = effect;
                    effectVO.trigger = trigger;
                    effectVO.param = param;
                    effectVO.content = textArea.text.substring(beginIndex, endIndex);
                    updateEffectMark(effectVO);

                    this.dispatchEvent(new InTextEditerEvent(InTextEditerEvent.EDITER_CHANGE, keywords, questions, effects));
                }

            }

            /*-----------------------------------------------------------*/


            /*
             ********************* 内部方法 ******************
             */

            //---------------------------关键词句部分----------------------
            /**
             * 删除关键词句
             *
             */
            private function delKeyword(keywordVO:KeywordVO):void
            {
                for (var i:int = 0; i < keywords.length; i++)
                {
                    if (keywordVO == keywords[i])
                    {
                        removeKeywordMark(keywords[i]);
                        keywords.splice(i, 1);
                        break;
                    }
                }

                this.dispatchEvent(new InTextEditerEvent(InTextEditerEvent.EDITER_CHANGE, keywords, questions, effects));
            }

            private function createKeywordMark(keyword:KeywordVO):void
            {
                var keywordMark:KeywordMark = new KeywordMark(keyword);
                keywordMark.addEventListener(MouseEvent.CLICK, keywordMark_clickHandler);
                keywordMarks.push(keywordMark);

                textAreaContainer.addElement(keywordMark);
            }

            private function keywordMark_clickHandler(e:MouseEvent):void
            {
                var keywordMark:KeywordMark = e.currentTarget as KeywordMark;
                setSelection(keywordMark.vo.beginIndex, keywordMark.vo.endIndex);
            }

            private function removeKeywordMark(keyword:KeywordVO):void
            {
                var keywordMark:KeywordMark = null;

                for (var i:int = 0; i < keywordMarks.length; i++)
                {
                    if (keywordMarks[i].vo == keyword)
                    {
                        keywordMark = keywordMarks[i];
                        keywordMark.removeEventListener(MouseEvent.CLICK, keywordMark_clickHandler);
                        keywordMarks.splice(i, 1);
                        textAreaContainer.removeElement(keywordMark);
                        break;
                    }
                }
            }

            private function updateKeywordMark(keyword:KeywordVO):void
            {
                var keywordMark:KeywordMark = null;

                for (var i:int = 0; i < keywordMarks.length; i++)
                {
                    if (keywordMarks[i].vo == keyword)
                    {
                        keywordMark = keywordMarks[i];

                        keywordMark.update(keywordMark.vo.beginIndex, keywordMark.vo.endIndex, textArea);
                        break;
                    }
                }
            }

            private function createKeywordMarks():void
            {
                clearKeywordMarks();

                for (var i:int = 0; i < keywords.length; i++)
                {
                    createKeywordMark(keywords[i]);
                }
            }

            private function clearKeywordMarks():void
            {
                for (var i:int = 0; i < keywords.length; i++)
                {
                    removeKeywordMark(keywords[i]);
                }
            }

            //---------------------------问题设置部分----------------------
            //
            //相关的方法依次对应下去
            //1.根据问题的VO对象删除问题
            //2.根据问题的VO对象绘制问题的显示标记
            //3.根据问题的VO对象删除问题的显示标记
            //4.根据问题的VO对象来更新问题的现实标记
            //

            //删除
            private function delQuestion(question:QuestionVO):void
            {
                var i:int = 0;

                var answers:Vector.<AnswerVO> = question.answers.concat();

                for (i = 0; i < answers.length; i++)
                {
                    delAnswer(answers[i]);
                }

                for (i = 0; i < questions.length; i++)
                {
                    if (question == questions[i])
                    {
                        removeQuestionMark(questions[i]);
                        questions.splice(i, 1);
                        break;
                    }
                }

                this.dispatchEvent(new InTextEditerEvent(InTextEditerEvent.EDITER_CHANGE, keywords, questions, effects));
            }

            //创建
            private function createQuestionMark(question:QuestionVO):QuestionMark
            {
                var questionMark:QuestionMark = new QuestionMark(question);
                //                questionMark.addEventListener(MouseEvent.ROLL_OVER, questionMark_rollOverHandler);
                questionMark.addEventListener(MouseEvent.CLICK, questionMark_clickHandler);
                questionMarks.push(questionMark);
                textAreaContainer.addElement(questionMark);
                return questionMark;
            }

            //删除
            private function removeQuestionMark(question:QuestionVO):void
            {
                var questionMark:QuestionMark = null;

                for (var i:int = 0; i < questionMarks.length; i++)
                {
                    if (questionMarks[i].vo == question)
                    {
                        questionMark = questionMarks[i];
                        questionMarks.splice(i, 1);
                        textAreaContainer.removeElement(questionMark);
                        break;
                    }
                }
            }

            //更新
            private function updateQuestionMark(question:QuestionVO):QuestionMark
            {
                var questionMark:QuestionMark = null;

                for (var i:int = 0; i < questionMarks.length; i++)
                {
                    if (questionMarks[i].vo == question)
                    {
                        questionMark = questionMarks[i];

                        var rect:Rectangle = TextAreaUtil.getBoundRectOfIndex(questionMark.vo.questionIndex, textArea);

                        if (rect == null)
                        {
                            rect = TextAreaUtil.getBoundRectOfIndex(questionMark.vo.questionIndex - 1, textArea);
                        }
                        questionMark.x = rect.x + textArea.x;
                        questionMark.y = rect.y + textArea.y;
                        break;
                    }
                }

                return questionMark;
            }

            /**
             * 问题边框
             */
            private var questionBorder:QuestionBorder = new QuestionBorder();

            private function questionMark_clickHandler(e:MouseEvent):void
            {
                //                selectedQuestionMark = e.currentTarget as QuestionMark
                //                questionInputBox.show(selectedQuestionMark);
                activateQuestion(e.currentTarget as QuestionMark);
            }

            private function activateQuestion(questionMark:QuestionMark):void
            {
                selectedQuestionMark = questionMark;
                questionInputBox.show(selectedQuestionMark);
            }

            private function createQuestionMarks():void
            {
                clearQuestionMarks();

                for (var i:int = 0; i < questions.length; i++)
                {
                    createQuestionMark(questions[i]);

                    for (var j:int = 0; j < questions[i].answers.length; j++)
                    {
                        createAnswerMark(questions[i].answers[j]);
                    }
                }
            }

            private function clearQuestionMarks():void
            {
                for (var i:int = 0; i < questions.length; i++)
                {
                    for (var j:int = 0; j < questions[i].answers.length; j++)
                    {
                        removeAnswerMark(questions[i].answers[j]);
                    }
                    removeQuestionMark(questions[i]);
                }
            }

            //-------------------------------------答案设置部分----------------------------------------

            /**
             * 删除答案
             *
             */
            private function delAnswer(answer:AnswerVO):void
            {
                for (var questionIndex:int = 0; questionIndex < questions.length; questionIndex++)
                {
                    for (var answerIndex:int = 0; answerIndex < questions[questionIndex].answers.length; answerIndex++)
                    {
                        if (questions[questionIndex].answers[answerIndex] == answer)
                        {
                            removeAnswerMark(questions[questionIndex].answers[answerIndex]);
                            questions[questionIndex].answers.splice(answerIndex, 1);
                            break;
                        }
                    }
                }

                this.dispatchEvent(new InTextEditerEvent(InTextEditerEvent.EDITER_CHANGE, keywords, questions, effects));
            }

            private function createAnswerMark(answer:AnswerVO):void
            {
                var answerMark:AnswerMark = new AnswerMark(answer);
                answerMark.addEventListener(MouseEvent.CLICK, answerMark_clickHandler);
                answerMarks.push(answerMark);
                textAreaContainer.addElement(answerMark);
            }

            private function removeAnswerMark(answer:AnswerVO):void
            {
                var answerMark:AnswerMark = null;

                for (var i:int = 0; i < answerMarks.length; i++)
                {
                    if (answerMarks[i].vo == answer)
                    {
                        answerMark = answerMarks[i];
                        answerMarks.splice(i, 1);
                        textAreaContainer.removeElement(answerMark);
                        break;
                    }
                }
            }

            private function updateAnswerMark(answer:AnswerVO):void
            {
                var answerMark:AnswerMark = null;

                for (var i:int = 0; i < answerMarks.length; i++)
                {
                    if (answerMarks[i].vo == answer)
                    {
                        answerMark = answerMarks[i];

                        //                        var rect:Rectangle = TextAreaUtil.getBoundRectOfIndex(answerMark.vo.beginIndex, textArea);
                        //
                        //                        answerMark.x = rect.x + textArea.x;
                        //                        answerMark.y = rect.y + textArea.y;
                        answerMark.update(answerMark.vo.beginIndex, answerMark.vo.endIndex, textArea);
                        break;
                    }
                }
            }

            private function answerMark_clickHandler(e:MouseEvent):void
            {
                var answerMark:AnswerMark = e.currentTarget as AnswerMark;
                setSelection(answerMark.vo.beginIndex, answerMark.vo.endIndex);
            }

            //----------------------特效设置部分-----------------------------------------------

            private function delEffect(effect:EffectVO):void
            {
                for (var i:int = 0; i < effects.length; i++)
                {
                    if (effect == effects[i])
                    {
                        removeEffectMark(effects[i]);
                        effects.splice(i, 1);
                        break;
                    }
                }

                this.dispatchEvent(new InTextEditerEvent(InTextEditerEvent.EDITER_CHANGE, keywords, questions, effects));
            }

            private function createEffectMark(effect:EffectVO):void
            {
                var effectMark:EffectMark = new EffectMark(effect);
                effectMark.addEventListener(MouseEvent.CLICK, effectMark_clickHandler);
                effectMarks.push(effectMark);
                textAreaContainer.addElement(effectMark);
            }

            private function effectMark_clickHandler(e:MouseEvent):void
            {
                var effectMark:EffectMark = e.currentTarget as EffectMark;
                setSelection(effectMark.vo.beginIndex, effectMark.vo.endIndex);
            }

            private function removeEffectMark(effect:EffectVO):void
            {
                for (var i:int = 0; i < effectMarks.length; i++)
                {
                    if (effectMarks[i].vo == effect)
                    {
                        effectMarks[i].removeEventListener(MouseEvent.CLICK, effectMark_clickHandler);
                        textAreaContainer.removeElement(effectMarks[i]);
                        effectMarks.splice(i, 1);
                        break;
                    }
                }
            }

            private function updateEffectMark(effect:EffectVO):void
            {
                for (var i:int = 0; i < effectMarks.length; i++)
                {
                    if (effectMarks[i].vo == effect)
                    {
                        effectMarks[i].update(effect.beginIndex, effect.endIndex, textArea);
                        break;
                    }
                }
            }

            private function createEffectMarks():void
            {
                clearEffectMarks();

                for (var i:int = 0; i < effects.length; i++)
                {
                    createEffectMark(effects[i]);
                }
            }

            private function clearEffectMarks():void
            {
                for (var i:int = 0; i < effects.length; i++)
                {
                    removeEffectMark(effects[i]);
                }
            }

            protected function textArea_mouseUpHandler(event:MouseEvent):void
            {
                if (textArea.selectionActivePosition != textArea.selectionAnchorPosition && selectedQuestionMark != null)
                {
                    this.addElement(answerSetButton);
                    answerSetButton.x = mouseX;
                    answerSetButton.y = mouseY;
                }
                else
                {
                    if (answerSetButton.owner == this)
                    {
                        this.removeElement(answerSetButton);
                    }
                }
            }
        ]]>
    </fx:Script>

    <fx:Declarations>
        <!-- 将非可视元素（例如服务、值对象）放在此处 -->
    </fx:Declarations>
    <s:Scroller id="scroller"
                width="100%"
                height="100%">
        <s:Group id="textAreaContainer"
                 width="100%"
                 height="100%">
            <s:TextArea x="{paddingX}"
                        y="10"
						right="10"
                        leadingModel="ascentDescentUp"
                        lineHeight="10"
                        id="textArea"
                        focusEnabled="false"
                        width="100%"
                        height="100%"
                        selectionHighlighting="always"
                        contentBackgroundAlpha="0"
                        borderAlpha="0"
                        resize="textArea_resizeHandler(event)"
                        selectionChange="textArea_selectionChangeHandler(event)"
                        change="textArea_changeHandler(event)"
                        mouseUp="textArea_mouseUpHandler(event)">
                <s:content>
                    <s:p>
			轻轻的我走了，
			正如我轻轻的来；
			我轻轻的招手，
			作别西天的云彩。
		    </s:p>
                    <s:p>
			那河畔的金柳，
			是夕阳中的新娘；
			波光里的艳影，
			在我的心头荡漾。
			</s:p>
                    <s:p>
			软泥上的青荇，
			油油的在水底招摇；
			在康河的柔波里，
			我甘心做一条水草！
			</s:p>
                </s:content>
            </s:TextArea>
        </s:Group>
    </s:Scroller>
</s:Group>
